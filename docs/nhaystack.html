<p><link href="markdown.css" rel="stylesheet"/></p>
<h2 id="nhaystack-nhaystack"><img src="docs/tag.png" alt="NHaystack" /> NHaystack</h2>
<p>NHaystack is an open-source <a href="https://www.tridium.com/en/products-services/niagara-ax">Niagara AX</a> and module that enables Niagara stations (JACE and WebSupervisor) to act as either servers <em>or</em> clients in the <a href="http://project-haystack.org">Project Haystack</a> format, via a <a href="http://project-haystack.org/doc/Rest">RESTful</a> protocol. Using NHaystack, external applications receive data that includes essential meta data (tags) to describe the meaning of the data.</p>
<p>When acting as a server, NHaystack automatically generates standard tags for all the ControlPoints in your system. This feature allows for connecting immediately to the Niagara Station via Haystack once the NHaystack module has been installed, without requiring any further configuration. It makes discovering the points in your station as easy as issuing a simple query.</p>
<p>NHaystack-as-a-server also streamlines the process of adding user-specified Haystack tags to Niagara systems, by providing a GUI tool that allows users to add the tags directly to Niagara components. Once tags have been defined, the data associated with the Niagara components, including the tags, are available over the Rest communications interface. This combination of the tagging tool and the Haystack protocol &quot;engine&quot; reduces the effort involved in connecting Niagara data to external software applications.</p>
<p>NHaystack can also act as a Haystack client, via an AX driver that models remote servers as AX devices. This allows haystack devices to exist &quot;underneath&quot; AX stations. See Section 7 of this document for an explanation of how that works.</p>
<p>NHaystack is licensed under the <a href="http://opensource.org/licenses/AFL-3.0">Academic Free License (&quot;AFL&quot;) v. 3.0</a>.</p>
<p>The development of NHaystack has been funded by <a href="http://www.j2inn.com">J2 Innovations</a>.</p>
<p>Further development has been undertaken by <a href="http://www.conserveit.com.au">Conserve it</a> and <a href="http://www.airmaster.com.au">Airmaster</a>.</p>
<h2 id="community-contributors">Community Contributors</h2>
<p>The following members of the community of contributed code to NHaystack:</p>
<ul>
<li>Christian Tremblay, <a href="http://www.servisys.com">Servisys</a></li>
</ul>
<h3 id="benefits">Benefits</h3>
<ul>
<li>The ability to include meta data tags as part of Niagara data structures allows external applications to automatically interpret the meaning of data acquired from a Niagara system.</li>
<li>The Haystack HTTP protocol is efficient and includes features coalesce requests to minimize network traffic and message size.</li>
<li>The NHaystack module includes extensive features under the covers to unify real time and historical data structures in Niagara, which greatly simplifies access to data, and presentation in third party applications.</li>
<li>The Haystack HTTP protocol tightly defines the relationship between client and server machines, allowing for third-parties to integrate easily with your equipment and data.</li>
</ul>
<h3 id="key-features">Key Features</h3>
<ul>
<li>Provides drop-in support for the Haystack protocol on a Niagara AX system.</li>
<li>Unifies the Component and History namespaces</li>
<li>Allows for arbitrary queries of the station based on Haystack tags</li>
<li>Makes it easy to create a Site-Equip-Point Hierarchy view of your system.</li>
<li>Provides a standard Niagara AX driver so that remote Haystack servers can be modelled inside of Niagara AX.</li>
</ul>
<h3 id="using-nhaystack-as-a-server">1. Using NHaystack as a server</h3>
<p>To get started with exposing an AX station as a haystack server, install nhaystack.jar into an AX station. Then open the nhaystack palette in Workbench, and drag-and-drop the NHaystackService onto the &quot;/Services&quot; folder of your station.</p>
<p>This is all you need to do to get rolling. Your station is now automatically serving up all its ControlPoint objects and Histories as haystack <code>point</code> <a href="http://project-haystack.org/doc/TagModel#entities">recs</a>, via the <a href="http://project-haystack.org/doc/Rest">Haystack REST Api</a>. Many of the tags that are defined as being associated with <code>points</code>, like <code>kind</code>, <code>unit</code>, <code>tz</code>, <code>his</code>, <code>cur</code>, etc. are automatically generated for you.</p>
<h3 id="how-point-recs-are-generated">2. How point recs are generated</h3>
<p>In Niagara AX, ControlPoints and Histories exist in separate namespaces. There is one object in the station database which represents the current state of the point, (including its current value, actions to command it, and so forth), and a different object to represent its historical log of timestamp/value pairs.</p>
<p>However, in Haystack, a <code>point</code> rec models both of these concepts in one object. A <code>point</code> rec can have both a <code>cur</code> tag, which indicates the <code>point</code> has capability for subscription to its real-time current value, and it can have a <code>his</code> tag, which indicates that a <code>point</code> is historized with a history log of timestamp/value pairs.</p>
<p>NHaystack handles this mismatch by unifiying the AX namespaces. It automatically maps ControlPoints and Histories together so that only one Haystack rec is generated, with both a <code>cur</code> tag and a <code>his</code> tag. If only one of the objects is present, then either the <code>cur</code> tag or this <code>his</code> tag is generated, but not both. Lets look at a couple of examples showing how this works.</p>
<h4 id="a-simple-station">2.1 A simple station</h4>
<p>First lets take a simple example of a Niagara station that has two ControlPoints in it , with no History collection for those ControlPoints. The station will look similar to this:</p>
<pre><code>station:|slot:/AHU1/NumericWritable
station:|slot:/AHU1/BooleanWritable
history:/my_station/AuditHistory
history:/my_station/LogHistory</code></pre>
<p>This station will automatically have four <code>point</code> recs: two for the ControlPoints, and two for the Histories. The first two will have a <code>cur</code> tag, but no <code>his</code> tag, and the second two will have a <code>his</code> tag but no <code>cur</code> tag.</p>
<pre><code>{point,cur} station:|slot:/AHU1/NumericWritable           
{point,cur} station:|slot:/AHU1/BooleanWritable           
{point,his} history:/my_station/AuditHistory 
{point,his} history:/my_station/LogHistory   </code></pre>
<p>Now lets add a NumericCov extension to the NumericWritable and enable it. Whenever we make a structural change to a station, by adding or removing a Component or History, we must invoke an action on the NHaystackService called <code>rebuildCache</code>. Invoking <code>rebuildCache</code> causes the NHaystack Server to traverse through the entire station and rebuild all of its internal data structures, so it can keep track of how everything in the station is interrelated.</p>
<p>After we invoke <code>rebuildCache</code>, the station will look like this:</p>
<pre><code>{point,cur,his} station:|slot:/AHU1/NumericWritable
{point,cur}     station:|slot:/AHU1/BooleanWritable
{point,his}     history:/my_station/AuditHistory
{point,his}     history:/my_station/LogHistory
----            history:/my_station/NumericWritable</code></pre>
<p>The station still has the same four <code>point</code> recs. However, a <code>his</code> tag has been added to the NumericWritable <code>point</code>. If a <a href="http://project-haystack.org/doc/Ops#hisRead">hisRead</a> on that <code>point</code> is performed, the NHaystack Server will fetch the timestamp/value pairs for the associated History. The History for NumericWritable does not have its own rec created, because it has been unified with the NumericWritable.</p>
<p>By the way, the <code>id</code> tags that are generated for these recs consist of a single character, either &quot;c&quot; or &quot;h&quot; (which indicates whether the rec comes from the ComponentSpace or HistorySpace), followed by a &quot;.&quot;, and then followed by a Uri-friendly Base64 encoding of either the slotPath or the historyId.</p>
<p>As a final example from this simple station, lets delete the NumericWritable and then invoke <code>rebuildCache</code>. The station now looks like this:</p>
<pre><code>{point,cur} station:|slot:/AHU1/BooleanWritable           
{point,his} history:/my_station/AuditHistory 
{point,his} history:/my_station/LogHistory   
{point,his} history:/my_station/NumericWritable    </code></pre>
<p>We still have four <code>point</code> recs. However, the first rec is now gone. In its place we have a <code>point</code> rec for the NumericWritable History. Note that this rec has a different <code>id</code> than the rec that has disappeared.</p>
<h4 id="a-more-complex-station">2.2 A more complex station</h4>
<p>Now lets look at a more complex station -- one that is similar to what one often sees on an AX Supervisor. A very frequent case for supervisors is that they just import lots of Histories from jaces.</p>
<pre><code>----        station:|slot:/Drivers/NiagaraNetwork/jace1/Histories/Remote_NumericWritable
----        station:|slot:/Drivers/NiagaraNetwork/jace1/Histories/Remote_BooleanWritable
----        station:|slot:/Drivers/NiagaraNetwork/jace2/Histories/Remote_NumericWritable
----        station:|slot:/Drivers/NiagaraNetwork/jace2/Histories/Remote_BooleanWritable
{point,his} history:/supervisor/AuditHistory
{point,his} history:/supervisor/LogHistory
{point,his} history:/jace1/NumericWritable
{point,his} history:/jace1/BooleanWritable
{point,his} history:/jace2/NumericWritable
{point,his} history:/jace2/BooleanWritable</code></pre>
<p>This station has six recs: two for the station's own audit and log Histories, and four for the imported Histories. Note that the four NiagaraHistoryImport objects do not have a <code>point</code> associated with them.</p>
<p>Now lets change the station by importing the ControlPoints for the first jace, and running <code>rebuildCache</code>. Here is what the station looks like now:</p>
<pre><code>{point,cur,his} station:|slot:/Drivers/NiagaraNetwork/jace1/points/NumericWritable
{point,cur,his} station:|slot:/Drivers/NiagaraNetwork/jace1/points/BooleanWritable
----            station:|slot:/Drivers/NiagaraNetwork/jace1/Histories/Remote_NumericWritable
----            station:|slot:/Drivers/NiagaraNetwork/jace1/Histories/Remote_BooleanWritable
----            station:|slot:/Drivers/NiagaraNetwork/jace2/Histories/Remote_NumericWritable
----            station:|slot:/Drivers/NiagaraNetwork/jace2/Histories/Remote_BooleanWritable
{point,his}     history:/supervisor/AuditHistory
{point,his}     history:/supervisor/LogHistory
----            history:/jace1/NumericWritable
----            history:/jace1/BooleanWritable
{point,his}     history:/jace2/NumericWritable
{point,his}     history:/jace2/BooleanWritable</code></pre>
<p>You'll notice that the two Histories from jace1 no longer have their own auto-generated rec. Instead, the two imported ControlPoints know about those Histories, and will export them via <a href="http://project-haystack.org/doc/Ops#hisRead">hisRead</a>. NHaystack creates this linkage by analyzing the relationships between imported ControlPoints found under a NiagaraPointDeviceExt, imported NiagaraHistoryImports found under a NiagaraHistoryDeviceExt, and the Histories found in the station's HistorySpace.</p>
<h4 id="curval-and-curstatus">2.3 curVal and curStatus</h4>
<p>If NHaystack creates a <a href="http://project-haystack.org/tag/cur">cur</a> tag, then it will also create a <a href="http://project-haystack.org/tag/curStatus">curStatus</a> tag, and (usually) a <a href="http://project-haystack.org/tag/curVal">curVal</a> tag.</p>
<p>In AX, a Status value is a set of flags, and at least in theory a given Status can contain any combination of the flags. However, in the haystack tagging system, <code>curStatus</code> always only has exactly one value -- one of &quot;ok&quot;, &quot;fault&quot;, &quot;down&quot;, &quot;disabled&quot;, or &quot;unknown&quot;.</p>
<p>NHaystack translates from an AX Status to curStatus by checking the following AX Status flags in order:</p>
<pre><code>AX ok       maps to `curStatus`:&quot;ok&quot;
AX disabled maps to `curStatus`:&quot;disabled&quot;
AX fault    maps to `curStatus`:&quot;fault&quot;
AX down     maps to `curStatus`:&quot;down</code></pre>
<p><em>Anything else</em> (overridden, null, alarm, stale, unackedAlarm) is simply translated into <code>curStatus</code>:&quot;ok&quot;.</p>
<p>NHaystack creates a <code>curVal</code> tag <em>only</em> if <code>curStatus</code> is &quot;ok&quot; <em>and</em> the AX status is not null. This means that if a point in AX has the &quot;null&quot; status flag set, then it will be reported with a curStatus of &quot;ok&quot;, but it will simply not have a curVal.</p>
<h3 id="tagging-via-the-haystack-slot">3. Tagging via the &quot;haystack&quot; slot</h3>
<h4 id="basic-concepts">3.1 Basic concepts</h4>
<p>For many use cases of NHaystack, you will not need to do any explicit tagging on the station. However, sometimes you want to actually add tags to the recs that are generated. NHaystack supports this via the following convention: if there is a slot called &quot;haystack&quot; on a Component, and that slot is of type <code>nhaystack:HDict</code>, then the tags which are saved in that slot are exported in the rec along with all the auto-generated tags. There is a Workbench FieldEditor for HDict which allows you to edit these tags. In addition, this FieldEditor shows you all the auto-generated tags (though you cannot edit them).</p>
<p>You can add this slot via the SlotSheet View for the Component. However this is very tedious when you have to do it to many Components, so nhaystack provides a better way. There is a Workbench View on NHaystackService that has an area that you can drag-and-drop Components into. The area says &quot;Drag Components here to add a 'haystack' slot&quot;. When you drop Components there, they will have a <code>nhaystack:HDict</code> &quot;haystack&quot; slot added automatically.</p>
<p>There is a special tag called &quot;axAnnotated&quot; that is automatically generated for those Components that have a &quot;haystack&quot; slot. This can be helpful if you need to query your system to figure out which parts of it have already been annotated.</p>
<p>By the way, you may be wondering why <code>nhaystack:HDict</code> doesn't just appear in the palette. The reason for this is that <code>nhaystack:HDict</code> is a <code>baja:Simple</code>, and sadly Simples cannot be placed in a palette.</p>
<p>Whenever you alter a tag with the FieldEditor, you usually need to run <code>rebuildCache</code>. Its best to just get in the habit of running it any time you change a tag or alter the structure of a station.</p>
<p>Note that tagging of Histories is not currently supported.</p>
<h4 id="automating-explicit-tagging">3.2 Automating explicit tagging</h4>
<p>As described above it is possible to explicitly tag a BControlPoint in a station that implements NHaystack. Depending on the size of your station this could be quite a time consuming tasks. In addition many users of Niagara AX reuse similar point names within their stations across projects and having to tag the same points with the same tags on repeated projects can waste a lot for time and incur a lot of unnecessary cost to the customer.</p>
<p>Starting in version 1.3.0 functionality has been added to allow the System Integrator to define standard tag sets that are to be automatically applied to a point on the basis of the point name in the station. By adding some simple GUI functionality a System Integrator can add explicit tags in a uniform fashion and save time and money.</p>
<p>In order to achieve this saving, a System Integrator must define their own local &quot;tag dictionary&quot;. This dictionary can reside on the local PC of the SI and can be edited right in the Niagara AX Workbench.</p>
<div class="figure">
<img src="docs/service.PNG" alt="New service view" /><p class="caption">New service view</p>
</div>
<p>If you change your local dictionnary file (local:|file:/C:nHaystack/customTagsDict.csv) just push the &quot;Reload Custom Tag List&quot; button and all new haystack slot will use the new file to tag your points based on name.</p>
<p>Note that if the file doesn't exist, you will get an error. To make this feature work, create a folder named &quot;nHaystack&quot; in your shared folder. Then create a simple file named customTagsDict.csv.</p>
<p>The format of the file is the following ::</p>
<pre><code>name,markers
DA-T,discharge air temp sensor
DAT-SP,discharge air temp sp</code></pre>
<h3 id="how-site-and-equip-tags-work">4. How site and equip tags work</h3>
<p>In addition to tagging <code>point</code> recs, you may also want to include <code>site</code> and <code>equip</code> recs in your station, and link everything together via <code>siteRef</code> and <code>equipRef</code> pointers. NHaystack does support creating this <a href="http://project-haystack.org/doc/Structure">site-equip-point hierarchy</a>. Let's see how it works.</p>
<h4 id="site-tagging">4.1 Site tagging</h4>
<p>Lets use our simple example station from section 2.1, except we'll add an EnumWritable to it. Note that this time we have also listed an entry for the parent &quot;AHU1&quot; folder in our simplified view of the station.</p>
<pre><code>----        station:|slot:/AHU1
{point,cur} station:|slot:/AHU1/NumericWritable
{point,cur} station:|slot:/AHU1/BooleanWritable
{point,cur} station:|slot:/AHU1/EnumWritable
{point,his} history:/my_station/AuditHistory
{point,his} history:/my_station/LogHistory</code></pre>
<p>If you look in the nhaystack palette, you'll see that there are Components for Site and Equip. Drag a Site over and drop it anywhere in the ComponentSpace, and then run <code>rebuildCache</code>. The station will now look something like this:</p>
<pre><code>{site}      station:|slot:/Richmond
----        station:|slot:/AHU1
{point,cur} station:|slot:/AHU1/NumericWritable           
{point,cur} station:|slot:/AHU1/BooleanWritable           
{point,cur} station:|slot:/AHU1/EnumWritable           
{point,his} history:/my_station/AuditHistory 
{point,his} history:/my_station/LogHistory   </code></pre>
<p>Site and Equip already have a &quot;haystack&quot; slot, so you don't have to add one via the SlotSheet. Bring up the HDict FieldEditor for the Site, you'll see that there are quite a few tags you can fill out, like the various &quot;geo&quot; tags.</p>
<h4 id="equipment-versus-controllers">4.2 Equipment versus Controllers</h4>
<p>In Niagara, Controllers are modeled as an object of type <code>driver:Device</code>. Generally speaking, all ControlPoints exist underneath one of these Devices.</p>
<p>Howerver, in nhaystack there is no one-to-one relationship between an <code>equip</code> rec and a Device. Any Device can have its <code>points</code> belong to more than one <code>equip</code>, and any <code>equip</code> can have <code>points</code> from more than one Device.</p>
<p>This flexibility allows us to get away completely from the network-centric view of the world that one finds in an AX Station. You can create representations of your data that reflect the real-world equipment on your site, rather than the layout of your controller network.</p>
<p>The following two sections, 4.3 and 4.4, explain in more detail how this works.</p>
<h4 id="explictly-tagging-points-with-equipref">4.3 Explictly tagging points with equipRef</h4>
<p>Lets continue with our example station from 4.1, and create an <code>equip</code> which references out <code>site</code>. Then lets have a <code>point</code> reference the <code>equip</code>.</p>
<p>First, drag an Equip over from the palette and place it anywhere in the station. Underneath the Site is a good place for it. Name it &quot;TrashCompactor&quot;.</p>
<p>Then edit the <code>equip</code> and assign its <code>siteRef</code> so that it references &quot;Richmond&quot;.<br />Then run <code>rebuildCache</code>. Next, edit &quot;/AHU1/BooleanWritable&quot;, and give it an <code>equipRef</code> that references &quot;TrashCompactor&quot;. Run <code>rebuildCache</code> again.</p>
<p>The station will now look like this:</p>
<pre><code>{site}                                 station:|slot:/Richmond
{equip,siteRef=&quot;/Richmond&quot;}            station:|slot:/Richmond/TrashCompactor
----                                   station:|slot:/AHU1
{point,cur}                            station:|slot:/AHU1/NumericWritable
{point,cur,equipRef=&quot;/TrashCompactor&quot;} station:|slot:/AHU1/BooleanWritable
{point,cur}                            station:|slot:/AHU1/EnumWritable
{point,his}                            history:/my_station/AuditHistory
{point,his}                            history:/my_station/LogHistory</code></pre>
<p>We have now successfully created a very simple site-equip-point hierarchy. Our nav tree looks like this:</p>
<pre><code>Richmond
    TrashCompactor
        BooleanWritable</code></pre>
<h4 id="implicitly-tagging-points-with-equipref">4.4 Implicitly tagging points with equipRef</h4>
<p>We could now continue and mark every single <code>point</code> under &quot;AHU1&quot; as belonging to some <code>equip</code>. However, that is a lot of drudgery, and its also prone to error. NHaystack provides us with a better way to do this.</p>
<p>Drag an Equip from the palette, drop it under the &quot;AHU1&quot; folder, and call it &quot;my_equip&quot;. Edit the <code>equip</code> so that its its <code>siteRef</code> references &quot;Richmond&quot;.</p>
<p>Next, add an optional &quot;Str&quot; tag called <code>navNameFormat</code> to the <code>equip</code>, and set its value to &quot;%parent.displayName%&quot;. The reason for doing this will soon become apparent.</p>
<p>Then rebuild the cache. Now observe what has happened:</p>
<pre><code>{site}                                 station:|slot:/Richmond
{equip,siteRef=&quot;/Richmond&quot;}            station:|slot:/TrashCompactor
----                                   station:|slot:/AHU1
{equip,siteRef=&quot;/Richmond&quot;}            station:|slot:/AHU1/my_equip
{point,cur,equipRef=&quot;/AHU1/my_equip&quot;}  station:|slot:/AHU1/NumericWritable
{point,cur,equipRef=&quot;/TrashCompactor&quot;} station:|slot:/AHU1/BooleanWritable
{point,cur,equipRef=&quot;/AHU1/my_equip&quot;}  station:|slot:/AHU1/EnumWritable
{point,his}                            history:/my_station/AuditHistory
{point,his}                            history:/my_station/LogHistory

Site-Equip-Point Nav Tree:
    Richmond
        TrashCompactor
            BooleanWritable
        AHU1
            NumericWritable
            EnumWritable</code></pre>
<p>All of the <code>points</code> underneath AHU1, except BooleanWritable, have an auto-generated <code>equipRef</code> tag which references &quot;/AHU1/equip&quot;. This happens because, during the cache rebuild process, NHaystack noticed that those 2 <code>points</code> had an ancestor which had an <code>equip</code> child. Since those <code>points</code> were not explicitly annotated with an <code>equipRef</code>, NHaystack automatically linked them to that ancestors Equip object.</p>
<p>By implicitly tagging <code>points</code> this way, we can automatically generate large numbers of <code>equipRef</code> tags without having to visit every <code>point</code>.</p>
<p>By the way, the reason that we added the <code>navNameFormat</code> to the <code>equip</code> was so that it would show up in our nav tree as &quot;AHU1&quot;, rather than &quot;my_equip&quot;. By default the <code>navName</code> of any object is just its AX displayName, but you can rig the nav tree so that alternate names are used. This is important because you must always ensure that all the children of a nav tree item have a unique <code>navName</code>.</p>
<p>Lets duplicate the &quot;AHU1&quot; folder (an then <code>rebuildCache</code> of course) to show how easy creating large nav trees is.</p>
<p>Before we do though, we'll fix our BooleanWritable so it has a better <code>navNameFormat</code>. Edit the tags for the BooleanWritable and set its <code>navNameFormat</code> to something like &quot;%parent.displayName%_%displayName%&quot;. By performing this step, we ensure that all of the points underneath &quot;TrashCompactor&quot; in the nav tree will have a unique <code>navName</code>. Now our nav tree looks like this:</p>
<pre><code>Site-Equip-Point Nav Tree:
    Richmond
        TrashCompactor
            AHU1_BooleanWritable
        AHU1
            NumericWritable
            EnumWritable</code></pre>
<p>Now simply duplicate AHU1 and run <code>rebuildCache</code>. Our station will look like this:</p>
<pre><code>{site}                                 station:|slot:/Richmond
{equip,siteRef=&quot;/Richmond&quot;}            station:|slot:/TrashCompactor
----                                   station:|slot:/AHU1
{equip,siteRef=&quot;/Richmond&quot;}            station:|slot:/AHU1/my_equip
{point,cur,equipRef=&quot;/AHU1/my_equip&quot;}  station:|slot:/AHU1/NumericWritable
{point,cur,equipRef=&quot;/TrashCompactor&quot;} station:|slot:/AHU1/BooleanWritable
{point,cur,equipRef=&quot;/AHU1/my_equip&quot;}  station:|slot:/AHU1/EnumWritable
----                                   station:|slot:/AHU2
{equip,siteRef=&quot;/Richmond&quot;}            station:|slot:/AHU2/my_equip
{point,cur,equipRef=&quot;/AHU2/my_equip&quot;}  station:|slot:/AHU2/NumericWritable
{point,cur,equipRef=&quot;/TrashCompactor&quot;} station:|slot:/AHU2/BooleanWritable
{point,cur,equipRef=&quot;/AHU2/my_equip&quot;}  station:|slot:/AHU2/EnumWritable
{point,his}                            history:/my_station/AuditHistory
{point,his}                            history:/my_station/LogHistory

Site-Equip-Point Nav Tree:
    Richmond
        TrashCompactor
            AHU1_BooleanWritable
            AHU2_BooleanWritable
        AHU1
            NumericWritable
            EnumWritable
        AHU2
            NumericWritable
            EnumWritable</code></pre>
<h3 id="keeping-your-data-set-consistent">5. Keeping your data set consistent</h3>
<h4 id="fixing-broken-refs">5.1 Fixing broken refs</h4>
<p>Occasionally when you are working on setting up the relationships between recs in a station, you will delete a Component that has other Components referencing it. For instance, in the example in 4.4, if we delete &quot;TrashCompactor&quot;, then both of our BooleanWritables will have an invalid equipRef.</p>
<p>To fix this problem, there is an action on NHaystackService called <code>removeBrokenRefs</code> that you can invoke. This action deletes all of the refs in the station that do not reference a valid rec. Each time a broken ref is deleted, a message is also generated in the station log telling you which Component was fixed.</p>
<p>In a future version of NHaystack, there will be a view on NHaystackService that will make it easier for you to find the broken refs and fix them.</p>
<h4 id="using-timezone-aliases">5.2 Using TimeZone Aliases</h4>
<p>Sometimes an AX TimeZone (a.k.a BTimeZone) do not map cleanly into a Haystack TimeZone (a.k.a HTimeZone). This happens when the BTimeZone uses an offset-style TimeZone ID, like &quot;GMT-05:00&quot;, rather than a valid <a href="https://en.wikipedia.org/wiki/Tz_database">Olson</a> ID, like &quot;America/New_York&quot;. When this occurs, you will see errors in your log output that look like this:</p>
<pre><code>ERROR [11:59:01 04-May-13 GMT-05:00][nhaystack] Cannot create tz tag: Unknown tz: GMT-05:00</code></pre>
<p>In cases like this, NHaystack simply omits the <code>tz</code> tag for the historized <code>point</code> in question.</p>
<p>However, NHaystack also allows you to provide a custom mapping that overcomes this problem, via the &quot;timeZoneAliases&quot; folder on your BHaystackService. Go to the nhaystack palette in Workbench, drag a &quot;timeZoneAlias&quot; onto the &quot;timeZoneAliases&quot; folder, and configure it so that the bogus AX TimeZone ID, like &quot;GMT-05:00&quot;, is mapped onto a proper HTimezone, such as &quot;America/New_York&quot;. Now when NHaystack is attempting to generate the <code>tz</code> tag, it will know how to proceed when it encounters non-Olson timezones.</p>
<p>In a future version of NHaystack, there will be a view on NHaystackService that will help you find which timezones are invalid in your dataset, but for now you must go through your log output, find the &quot;Cannot create tz tag&quot; error messages, and copy-and-paste the offending TimeZone ID into a timeZoneAlias that maps onto the 'real' HTimezone.</p>
<p>Note that if the machine that you are running Workbench from is mis-configured, it will provide a default HTimeZone of the form &quot;Etc/GMT-5&quot; in your timeZoneAlias. You should not use the HTimeZones from the &quot;Etc&quot; region unless you are really sure of what you are doing. Instead, always use the proper geographic region-and-timezone, like &quot;America/New_York&quot;.</p>
<h3 id="how-ids-are-generated">6. How IDs are generated</h3>
<p>Each haystack rec must have an ID that uniquely identifies the object that the rec models.</p>
<p>By default, nhaystack generates IDs based on the slotPath of components (or the history ID for histories that are not associate with a point). E.g:</p>
<pre><code>slot:/Foo/SineWave1 --&gt; C.Foo.SineWave1

history:/nhaystack_simple/AuditHistory --&gt; H.nhaystack_simple.AuditHistory</code></pre>
<p>In the above example, the &quot;C&quot; prefix stands for the ComponentSpace, and the &quot;H&quot; stands for the HistorySpace.</p>
<p>Note that IDs are bi-directionally encoded -- you can always recreate the slotPath from an ID and vice-versa.</p>
<p>Special characters in the slotPath are handled by replacing the &quot;$&quot; character with a &quot;~&quot; character. The sole exception to this rule is that &quot;$20&quot;, which represents a single &quot; &quot; character, is replaced with a dash, &quot;-&quot;, to improve the readability of the IDS. E.g:</p>
<pre><code>slot:/Foo/Sine$2fWave1 --&gt; C.Foo.Sine~2fWave1
slot:/Foo/Sine$20Wave1 --&gt; C.Foo.Sine-Wave1</code></pre>
<p>If there is a site-equip-point hierarchy created in the station, then nhaystack will use that to generate the ID rather than the slotPath. E.g. if the SineWave in the first example was tagged up with an equip and a site, then its generated ID might look something like this:</p>
<pre><code>slot:/Foo/SineWave1 --&gt; S.Carytown.AHU1.SineWave1</code></pre>
<p>In this case, there are actually two IDs that can be used to resolve the rec -- the slotPath version, and the Site-Equip-Point version.</p>
<p>Note that older versions of nhaystack used a Base64 encoding of the slot path, which looks something like this:</p>
<pre><code>c.c2xvdDovRm9vL1NpbmVXYXZlMg~~
h.L25oYXlzdGFja19zaW1wbGUvQXVkaXRIaXN0b3J5</code></pre>
<p>Nhaystack no longer generates IDs with this form, but it can resolve them.</p>
<h3 id="using-nhaystack-as-a-client">7. Using NHaystack as a client</h3>
<p>NHaystack can also model remote haystack servers as AX devices. This is done via a standard AX driver that maps the Haystack protocol into the AX driver framework.</p>
<p>You do <em>not</em> need to have an NHaystackService installed in your station to do this -- the driver is a standalone piece of functionality. In fact you <em>shouldn't</em> have an NHaystackService in the station unless you are acting simultaneously as a server and a client.</p>
<p>To get started, open the nhaystack palette in Workbench, open the &quot;drivers&quot; sub-folder of the palette, and drag-and-drop the NHaystackNetwork onto the &quot;/Drivers&quot; folder of your station. Then drag an NHaystackServer so that it is underneath your NHaystackNetwork.</p>
<p>Next, configure the internetAddress, uriPath, and credentials slots on the NHaystackServer. The internetAddress adress should just be the hostname or IP address (plus a colon and then the port number if something other than port 80 is being used). The uriPath should be of the form &quot;api/myProjectName&quot; if the remote server is running FIN|Stack or SkySpark. If the remote server is an AX station that is running nhaystack-as-a-server, then the uriPath should simply be &quot;haystack&quot;.</p>
<p>After you've configured the NHaystackServer, manually do a ping to make sure its connected. Once connectivity has been established, you can go to the &quot;points&quot; and &quot;histories&quot; folders of the NHaystackServer object, and discover points and histories just like any other Niagara driver.</p>
<p>Note that currently, the driver imports <a href="http://project-haystack.org/tag/point">&quot;Str&quot; points</a> as Baja BStringPoint and BStringWritable objects, even if the haystack point has an enum tag which specifies a list allowable values. BEnumPoint and BEnumWritable objects are currently not created by the driver. Instead, the enum tag is stored as a 'range' facet on the AX ControlPoint.</p>
